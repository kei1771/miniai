<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MiniPix — AI 그림 갤러리 (Fixed/Share/Mobile)</title>
<style>
:root{
  --bg:#fafbfd; --card:#fff; --muted:#6b7280; --accent:#2b6ef6; --danger:#c53;
  --gap:10px;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Noto Sans KR',sans-serif;background:var(--bg);color:#111;-webkit-font-smoothing:antialiased}
.topbar{display:flex;align-items:center;gap:12px;padding:10px;border-bottom:1px solid #eef2ff;background:#fff;position:sticky;top:0;z-index:60}
.brand{font-weight:700;color:var(--accent);text-decoration:none;font-size:18px;cursor:pointer}
.tools{margin-left:auto;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.btn{padding:8px 10px;border-radius:8px;border:1px solid #e6e9f2;background:#fff;cursor:pointer;font-size:14px}
.btn.primary{background:var(--accent);color:#fff;border:0}
.btn.danger{border-color:#f8d3d3;color:var(--danger)}
.container{max-width:1100px;margin:12px auto;padding:0 12px}
.gallery{display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:12px}
.card{background:#fff;border-radius:12px;overflow:hidden;border:1px solid #f0f3fb;cursor:pointer;position:relative;display:flex;flex-direction:column}
.card .thumb-wrap{flex:1;display:flex;align-items:center;justify-content:center;overflow:hidden;background:#f6f8fb;height:160px}
.card img.thumb{width:100%;height:100%;object-fit:cover;display:block}
.hover{position:absolute;inset:auto 0 0 0;background:linear-gradient(180deg,transparent,rgba(0,0,0,0.35));color:#fff;padding:8px;display:flex;flex-direction:column;justify-content:flex-end}
.hover .title{font-weight:600}
.hover .meta{font-size:12px;color:#e6eefc;margin-top:6px}
.empty{text-align:center;color:var(--muted);padding:30px}
.post-page{background:#fff;padding:14px;border-radius:10px;border:1px solid #eef2ff;margin-bottom:24px}
.image-stack{display:flex;flex-direction:column;gap:12px;margin:12px 0}
.image-stack img{width:100%;height:auto;border-radius:8px;display:block}
.post-body{white-space:pre-wrap;color:#222;margin-top:10px}
.tags{margin-top:8px}
.tag{display:inline-block;background:#eef2ff;color:var(--accent);padding:6px 8px;border-radius:6px;margin-right:6px;font-size:13px}
.editor{display:flex;flex-direction:column;gap:10px;background:#fff;padding:12px;border-radius:10px;border:1px solid #eef2ff}
input,textarea,select{padding:8px;border-radius:8px;border:1px solid #e6e9f2;font-size:14px}
.file{display:inline-block;padding:8px 12px;border-radius:8px;border:1px dashed #dfe7ff;background:#fbfcff;cursor:pointer}
.preview{display:flex;gap:8px;flex-wrap:wrap}
.preview img{width:96px;height:96px;object-fit:cover;border-radius:8px}
.row{display:flex;gap:8px;align-items:center}
.small{font-size:13px;color:var(--muted)}
.controls{display:flex;gap:8px;margin-top:12px}
.toolbar-search{display:flex;gap:8px;align-items:center;background:#fff;padding:6px;border-radius:8px;border:1px solid #eef2ff}
.input-search{padding:8px;border-radius:8px;border:1px solid #e6e9f2}
.carousel-thumbs{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
.carousel-thumbs img{width:64px;height:64px;object-fit:cover;border-radius:6px;cursor:pointer;border:2px solid transparent}
.nsfw-badge{position:absolute;left:8px;top:8px;background:#ffefd5;color:#b24;border-radius:6px;padding:4px 6px;font-size:12px;border:1px solid #ffd6a6}
@media (max-width:900px){
  .brand{font-size:16px}
  .card .thumb-wrap{height:140px}
  .preview img{width:72px;height:72px}
}
@media (max-width:520px){
  .topbar{padding:8px}
  .brand{font-size:15px}
  .gallery{grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:8px}
  .card .thumb-wrap{height:120px}
  .btn{padding:6px 8px;font-size:13px}
  .editor{padding:10px}
}
</style>
</head>
<body>
  <header class="topbar" role="banner">
    <div class="brand" id="brand">MiniPix — AI 그림 갤러리</div>
    <div class="tools">
      <div class="toolbar-search">
        <input id="search" class="input-search" placeholder="검색 (제목/본문/태그)" />
        <select id="sort" class="input-search" style="width:120px">
          <option value="desc">최신순</option>
          <option value="asc">오래된순</option>
        </select>
        <select id="filter" class="input-search" style="width:140px">
          <option value="all">전체</option>
          <option value="photos">사진</option>
          <option value="text">글</option>
          <option value="memo">메모</option>
        </select>
      </div>

      <div id="userArea" style="display:none;align-items:center;gap:8px;padding:6px 8px;border-radius:8px;background:#f6f8ff;border:1px solid #e6eefc">
        <span id="userName">Guest</span>
        <button id="logoutBtn" class="btn">로그아웃</button>
      </div>

      <button id="loginBtn" class="btn">로그인</button>
      <button id="registerBtn" class="btn">회원가입</button>
      <button id="settingsBtn" class="btn">설정</button>

      <button id="btnNew" class="btn primary">새 글 올리기</button>
      <button id="btnExport" class="btn">내보내기</button>
      <label class="btn file">가져오기<input id="importFile" type="file" accept="application/json" style="display:none" /></label>
      <button id="btnClear" class="btn">전체 삭제</button>
    </div>
  </header>

  <main class="container" id="app">
    <section id="gallery" class="gallery" aria-live="polite"></section>
    <div id="empty" class="empty" style="display:none">게시물이 없습니다. '새 글 올리기'로 시작하세요.</div>
  </main>

  <!-- Editor Modal (간단) -->
  <div id="editorModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.45);align-items:center;justify-content:center;padding:12px;z-index:120">
    <div style="width:100%;max-width:760px;background:#fff;border-radius:10px;padding:12px;max-height:90vh;overflow:auto;position:relative">
      <button id="editorClose" style="position:absolute;right:12px;top:12px;border:0;background:#fff;padding:6px;border-radius:6px;cursor:pointer">✕</button>
      <h3 id="editorTitle">새 글 올리기</h3>
      <form id="editorForm" class="editor" onsubmit="return false;">
        <input id="title" placeholder="제목 (선택)" />
        <textarea id="body" rows="6" placeholder="본문"></textarea>

        <div class="row">
          <label class="file">이미지 선택<input id="files" type="file" accept="image/*" multiple style="display:none" /></label>
          <div id="selectedNames" class="small" style="margin-left:8px">선택된 파일 없음</div>
          <div style="margin-left:auto" class="small">최대 200장 권장 • EXIF 제거</div>
        </div>

        <div class="preview" id="preview"></div>

        <input id="tags" placeholder="태그 (쉼표 구분)" />
        <div class="row">
          <select id="category"><option value="photos">사진</option><option value="text">글</option><option value="memo">메모</option></select>
          <label style="margin-left:8px"><input id="nsfwCheck" type="checkbox" /> NSFW</label>
          <div style="margin-left:auto;display:flex;gap:8px">
            <button id="btnSave" class="btn primary">저장</button>
            <button id="btnSaveClose" class="btn">저장 후 닫기</button>
          </div>
        </div>

        <div id="anonPassRow" style="display:none">
          <label class="small">익명 삭제용 비밀번호 (필수 - 익명 업로드 시)</label>
          <input id="anonPassword" placeholder="익명 글 삭제용 비밀번호" type="password" />
        </div>

        <div id="editorProgress" class="small" style="margin-top:8px"></div>
      </form>
    </div>
  </div>

  <!-- Post View (간단) -->
  <div id="postView" style="display:none;padding:12px;max-width:900px;margin:12px auto;z-index:30">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <h2 id="postTitleView">제목</h2>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="btnBack" class="btn">목록</button>
        <button id="btnEditPost" class="btn">편집</button>
        <button id="btnDeletePost" class="btn danger">삭제</button>
      </div>
    </div>

    <div class="post-page" id="postContent">
      <div id="metaView" class="small" style="color:var(--muted)"></div>
      <div class="image-stack" id="imageStack"></div>
      <div id="carouselThumbs" class="carousel-thumbs" style="display:none"></div>
      <div id="postBody" class="post-body"></div>
      <div id="postTags" class="tags"></div>
      <div style="margin-top:12px;display:flex;gap:8px;align-items:center">
        <a id="downloadLink" class="btn" href="#" download>원본 다운로드</a>
        <button id="copyBodyBtn" class="btn">본문 복사</button>
        <button id="bulkDownloadBtn" class="btn">일괄 다운로드</button>
      </div>
    </div>
  </div>

  <!-- Settings Modal (간단) -->
  <div id="settingsBackdrop" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.45);align-items:center;justify-content:center;padding:12px;z-index:220">
    <div style="background:#fff;padding:14px;border-radius:10px;max-width:520px">
      <h3>설정</h3>
      <label><input id="optAllowAnon" type="checkbox"> 익명 업로드 허용</label><br/>
      <label><input id="optRequireMember" type="checkbox"> 회원 전용 모드</label><br/>
      <label><input id="optAllowNSFW" type="checkbox"> NSFW 보기 허용</label><br/>
      <div style="margin-top:8px">
        <label class="small">공유 서버 URL (선택, 자동 동기화용)</label>
        <input id="backupServer" placeholder="https://example.com/api" style="width:100%"/>
        <div style="display:flex;gap:8px;margin-top:8px;justify-content:flex-end">
          <button id="btnBackupNow" class="btn">지금 백업</button>
          <button id="settingsClose" class="btn">닫기</button>
        </div>
      </div>
    </div>
  </div>

<script>
/* 핵심 수정 사항:
 - 로그인 상태를 sessionStorage로 관리(로그아웃 시 확실히 지워짐) -> 로그아웃 후 새로고침 재로그인 문제 해결
 - export/import 개선(이미지 포함)으로 수동으로 다른 기기에 옮길 수 있음
 - 모바일용 CSS 반응형 개선
 - 서버 동기화(자동 공유)를 위해 "공유 서버 URL" 입력 후 "지금 백업"으로 서버에 메타데이터 전송 가능 (서버 필요)
 - 주의: 완전한 자동 동기화/공유/중앙관리 기능은 서버가 필요합니다. 아래에 서버 예제 포함.
*/

/* 간단히 기존 코드의 핵심만 남기고 문제 해결에 필요한 부분들을 강화했습니다.
   - IndexedDB는 posts/users 스토어 유지
   - currentUser는 sessionStorage에 저장함 (로컬 브라우저 재시작 시 자동 로그인 원치 않으면 sessionStorage 사용)
*/

/* === 간단한 IndexedDB 헬퍼 및 앱 로직 === */
const DB_NAME = 'minipix-db-v2';
const STORE = 'posts';
const USER_STORE = 'users';
const DB_VERSION = 4;
const MAX_FILES = 200;

function openDB(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = e => {
      const db = e.target.result;
      if(!db.objectStoreNames.contains(STORE)){
        const os = db.createObjectStore(STORE,{keyPath:'id'});
        os.createIndex('created_at','created_at',{unique:false});
      }
      if(!db.objectStoreNames.contains(USER_STORE)){
        const us = db.createObjectStore(USER_STORE,{keyPath:'id'});
        us.createIndex('username','username',{unique:true});
      }
    };
    req.onsuccess = e => resolve(e.target.result);
    req.onerror = e => reject(e.target.error);
  });
}
async function dbPut(obj, store=STORE){ const db = await openDB(); return new Promise((res,rej)=>{ const tx = db.transaction(store,'readwrite'); tx.objectStore(store).put(obj); tx.oncomplete = ()=> res(obj); tx.onerror = e => rej(e.target.error); }); }
async function dbGet(id, store=STORE){ const db = await openDB(); return new Promise((res,rej)=>{ const tx = db.transaction(store,'readonly'); const r = tx.objectStore(store).get(id); r.onsuccess = ()=> res(r.result); r.onerror = e => rej(e.target.error); }); }
async function dbGetAll(store=STORE){ const db = await openDB(); return new Promise((res,rej)=>{ const tx = db.transaction(store,'readonly'); const r = tx.objectStore(store).getAll(); r.onsuccess = ()=> res(r.result || []); r.onerror = e => rej(e.target.error); }); }
async function dbDelete(id, store=STORE){ const db = await openDB(); return new Promise((res,rej)=>{ const tx = db.transaction(store,'readwrite'); tx.objectStore(store).delete(id); tx.oncomplete = ()=> res(); tx.onerror = e => rej(e.target.error); }); }
async function dbClear(store=STORE){ const db = await openDB(); return new Promise((res,rej)=>{ const tx = db.transaction(store,'readwrite'); tx.objectStore(store).clear(); tx.oncomplete = ()=> res(); tx.onerror = e => rej(e.target.error); }); }

function qs(sel, ctx=document){ return ctx.querySelector(sel); }
function qsa(sel, ctx=document){ return Array.from((ctx||document).querySelectorAll(sel)); }
function toast(msg, t=1400){ const e=document.createElement('div'); e.textContent=msg; e.style.position='fixed'; e.style.right='12px'; e.style.bottom='12px'; e.style.background='#111'; e.style.color='#fff'; e.style.padding='8px 12px'; e.style.borderRadius='8px'; e.style.zIndex=9999; document.body.appendChild(e); setTimeout(()=>e.remove(), t); }

async function hashPassword(password){
  if(window.crypto && crypto.subtle && typeof crypto.subtle.digest==='function'){
    const enc = new TextEncoder();
    const buf = await crypto.subtle.digest('SHA-256', enc.encode(password||''));
    return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
  } else {
    // fallback (not crypto-secure)
    let h=0; for(let i=0;i<password.length;i++){ h=((h<<5)-h)+password.charCodeAt(i); h|=0; } return 'f'+Math.abs(h);
  }
}

/* session 기반 로그인 관리: sessionStorage 사용.
   - 로그인 시 sessionStorage.setItem('minipix_user', JSON.stringify(userSummary))
   - 로그아웃 시 sessionStorage.removeItem('minipix_user') 및 localStorage 관련 항목도 제거
*/
function getSavedUser(){
  try{
    const s = sessionStorage.getItem('minipix_user');
    if(s) return JSON.parse(s);
    // fallback: if localStorage had older format, do not auto-login from it to avoid unexpected persistence
    return null;
  }catch(e){ return null; }
}
function saveUserSession(user){ if(user) sessionStorage.setItem('minipix_user', JSON.stringify(user)); else { sessionStorage.removeItem('minipix_user'); localStorage.removeItem('minipix_current_user'); } }

let currentUser = getSavedUser();

/* UI element refs */
const galleryEl = qs('#gallery');
const emptyEl = qs('#empty');
const brand = qs('#brand');
const searchInput = qs('#search');
const sortSelect = qs('#sort');
const filterSelect = qs('#filter');
const btnNew = qs('#btnNew');
const btnExport = qs('#btnExport');
const importFile = qs('#importFile');
const btnClear = qs('#btnClear');
const editorModal = qs('#editorModal');
const editorClose = qs('#editorClose');
const filesInput = qs('#files');
const selectedNames = qs('#selectedNames');
const previewEl = qs('#preview');
const titleInput = qs('#title');
const bodyInput = qs('#body');
const tagsInput = qs('#tags');
const categoryInput = qs('#category');
const btnSave = qs('#btnSave');
const btnSaveClose = qs('#btnSaveClose');
const editorProgress = qs('#editorProgress');
const anonPassRow = qs('#anonPassRow');
const anonPasswordInput = qs('#anonPassword');
const nsfwCheck = qs('#nsfwCheck');

const postView = qs('#postView');
const postTitleView = qs('#postTitleView');
const metaView = qs('#metaView');
const imageStack = qs('#imageStack');
const carouselThumbs = qs('#carouselThumbs');
const postBodyEl = qs('#postBody');
const postTagsEl = qs('#postTags');
const btnBack = qs('#btnBack');
const btnEditPost = qs('#btnEditPost');
const btnDeletePost = qs('#btnDeletePost');
const downloadLink = qs('#downloadLink');

const settingsBackdrop = qs('#settingsBackdrop');
const settingsClose = qs('#settingsClose');
const settingsBtn = qs('#settingsBtn');
const optAllowAnon = qs('#optAllowAnon');
const optRequireMember = qs('#optRequireMember');
const optAllowNSFW = qs('#optAllowNSFW');
const backupServerInput = qs('#backupServer');
const btnBackupNow = qs('#btnBackupNow');

const loginBtn = qs('#loginBtn');
const registerBtn = qs('#registerBtn');
const userArea = qs('#userArea');
const userName = qs('#userName');
const logoutBtn = qs('#logoutBtn');

/* 초기 설정 불러오기 */
let settings = { allowAnon:true, requireMember:false, allowNSFW:false };
try{ settings = Object.assign(settings, JSON.parse(localStorage.getItem('minipix_settings')||'{}')); }catch(e){}

/* UI 초기화 */
function updateAuthUI(){
  if(currentUser){
    userArea.style.display='flex';
    userName.textContent = currentUser.username + (currentUser.role==='admin' ? ' (관리자)' : '');
    loginBtn.style.display='none'; registerBtn.style.display='none';
  } else {
    userArea.style.display='none';
    loginBtn.style.display='inline-block'; registerBtn.style.display='inline-block';
  }
  updateEditorAnonRow();
}
function updateEditorAnonRow(){ anonPassRow.style.display = (!currentUser && settings.allowAnon) ? 'block' : 'none'; }

/* 부트 */
(async function boot(){
  attachEvents();
  updateAuthUI();
  await renderGallery();
})();

/* 렌더 갤러리 */
async function renderGallery(){
  const posts = await dbGetAll(STORE);
  let visible = posts.sort((a,b)=> sortSelect.value==='desc' ? b.created_at.localeCompare(a.created_at) : a.created_at.localeCompare(b.created_at));
  const q = (searchInput.value||'').trim().toLowerCase();
  const cat = filterSelect.value;
  visible = visible.filter(p=>{
    if(cat !== 'all' && p.category !== cat) return false;
    if(!q) return true;
    return (p.title||'').toLowerCase().includes(q) || (p.body||'').toLowerCase().includes(q) || (p.tags||[]).join(' ').toLowerCase().includes(q);
  });
  if(!settings.allowNSFW) visible = visible.filter(p=>!p.nsfw);
  galleryEl.innerHTML = '';
  if(!visible.length){ emptyEl.style.display='block'; galleryEl.style.display='none'; return; }
  emptyEl.style.display='none'; galleryEl.style.display='grid';
  visible.forEach(p=>{
    const card = document.createElement('div'); card.className='card';
    const wrap = document.createElement('div'); wrap.className='thumb-wrap';
    const img = document.createElement('img'); img.className='thumb'; img.alt = p.title || '이미지';
    if(p.thumbBlobs && p.thumbBlobs.length) img.src = URL.createObjectURL(p.thumbBlobs[0]);
    else img.src = 'data:image/svg+xml;utf8,'+encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="600" height="400"><rect width="100%" height="100%" fill="#f6f7fb"/></svg>');
    wrap.appendChild(img);
    card.appendChild(wrap);
    if(p.nsfw){ const nb=document.createElement('div'); nb.className='nsfw-badge'; nb.textContent='NSFW'; card.appendChild(nb); }
    const hover = document.createElement('div'); hover.className='hover';
    const author = p.authorName ? p.authorName : (p.anon ? '익명' : '비회원');
    hover.innerHTML = `<div class="title">${p.title?escapeHtml(p.title):'(제목없음)'}</div><div class="meta">${(p.tags||[]).slice(0,3).join(' · ')} · ${author} · ${new Date(p.created_at).toLocaleString()}</div>`;
    card.appendChild(hover);
    card.addEventListener('click', ()=> showPostView(p.id));
    galleryEl.appendChild(card);
  });
}

/* 게시물 보기 */
async function showPostView(id){
  const p = await dbGet(id);
  if(!p){ toast('게시물을 찾을 수 없습니다.'); return; }
  postView.style.display='block';
  document.getElementById('gallery').style.display='none';
  postTitleView.textContent = p.title || '(제목없음)';
  metaView.textContent = `${new Date(p.created_at).toLocaleString()} · ${p.category||''} · ${p.authorName || (p.anon ? '익명' : '비회원')}`;
  imageStack.innerHTML=''; carouselThumbs.innerHTML=''; carouselThumbs.style.display='none';
  if(p.mainBlobs && p.mainBlobs.length){
    p.mainBlobs.forEach((b,idx)=>{
      const img = document.createElement('img'); img.src = URL.createObjectURL(b); imageStack.appendChild(img);
      const t = document.createElement('img'); t.src = URL.createObjectURL((p.thumbBlobs && p.thumbBlobs[idx]) ? p.thumbBlobs[idx] : b);
      carouselThumbs.appendChild(t);
    });
    if(carouselThumbs.children.length) carouselThumbs.style.display='flex';
  }
  postBodyEl.textContent = p.body || '';
  postTagsEl.innerHTML=''; (p.tags||[]).forEach(t=>{ const sp=document.createElement('span'); sp.className='tag'; sp.textContent=t; postTagsEl.appendChild(sp); });
  downloadLink.href = (p.mainBlobs && p.mainBlobs[0]) ? URL.createObjectURL(p.mainBlobs[0]) : '#';
  downloadLink.download = (p.title?p.title.replace(/\s+/g,'_'):'image') + '.jpg';
}

/* 편집기 열기 */
btnNew.addEventListener('click', ()=>{
  if(settings.requireMember && !currentUser){ toast('회원 전용 모드입니다. 로그인하세요'); return; }
  if(!settings.allowAnon && !currentUser){ toast('익명 업로드 비활성화. 로그인 필요'); return; }
  editorModal.style.display='flex';
});

/* 파일선택 미리보기 */
filesInput.addEventListener('change', ()=>{
  const files = Array.from(filesInput.files || []);
  if(!files.length){ selectedNames.textContent='선택된 파일 없음'; previewEl.innerHTML=''; return; }
  selectedNames.textContent = files.map(f=>f.name).join(', ').slice(0,200);
  previewEl.innerHTML=''; files.slice(0,MAX_FILES).forEach(f=>{ const url=URL.createObjectURL(f); const im=document.createElement('img'); im.src=url; previewEl.appendChild(im); });
});

/* 저장 (간단 처리: 이미지 리사이즈 없이 바로 blob 저장—원본을 그대로 저장) */
btnSave.addEventListener('click', async ()=>{
  // 익명 업로드일 경우 비밀번호 필요
  if(!currentUser && settings.allowAnon){
    if(!anonPasswordInput.value || String(anonPasswordInput.value).trim().length < 4){ toast('익명 글 삭제 비밀번호(최소4자)를 입력하세요'); return; }
  }
  editorProgress.textContent = '저장 중...';
  try{
    const files = Array.from(filesInput.files || []).slice(0, MAX_FILES);
    const mainBlobs = []; const thumbBlobs = [];
    for(const f of files){
      if(!f.type.startsWith('image/')) continue;
      // 간단히 원본과 썸네일(쿼리용 소형 캔버스) 생성
      const dataUrl = await fileToDataUrl(f);
      const img = new Image(); img.src = dataUrl;
      await new Promise(r=>img.onload=r);
      // thumbnail
      const tcv = document.createElement('canvas'); const ctx = tcv.getContext('2d');
      const size = 300; tcv.width = size; tcv.height = size;
      const scale = Math.max(size / img.width, size / img.height);
      const sw = Math.round(img.width * scale), sh = Math.round(img.height * scale);
      const tmp = document.createElement('canvas'); tmp.width = sw; tmp.height = sh; tmp.getContext('2d').drawImage(img,0,0,sw,sh);
      const sx = Math.max(0, Math.round((sw - size) / 2)), sy = Math.max(0, Math.round((sh - size) / 2));
      ctx.drawImage(tmp, sx, sy, size, size, 0,0,size,size);
      const mainBlob = dataURLtoBlob(dataUrl);
      const thumbBlob = await new Promise(r=>tcv.toBlob(r,'image/jpeg',0.8));
      mainBlobs.push(mainBlob); thumbBlobs.push(thumbBlob);
    }
    const id = 'p_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2,8);
    const post = { id, created_at: new Date().toISOString(), title: titleInput.value.trim(), body: bodyInput.value.trim(), tags: (tagsInput.value||'').split(',').map(s=>s.trim()).filter(Boolean), category: categoryInput.value, mainBlobs, thumbBlobs, anon: !currentUser, authorId: currentUser ? currentUser.id : null, authorName: currentUser ? currentUser.username : null, anonPassHash: currentUser ? null : await hashPassword(String(anonPasswordInput.value||'')), nsfw: !!nsfwCheck.checked };
    await dbPut(post, STORE);
    toast('업로드 완료');
    editorModal.style.display='none'; editorProgress.textContent=''; await renderGallery();
  }catch(err){ console.error(err); toast('저장 실패'); editorProgress.textContent=''; }
});

/* 기타 버튼 */
editorClose.addEventListener('click', ()=>{ editorModal.style.display='none'; });
brand.addEventListener('click', ()=>{ document.getElementById('gallery').style.display='block'; postView.style.display='none'; });
btnExport.addEventListener('click', async ()=>{
  const posts = await dbGetAll(STORE);
  const out = [];
  for(const p of posts){
    const mainBase = p.mainBlobs ? await Promise.all(p.mainBlobs.map(b=>blobToBase64(b))) : null;
    const thumbBase = p.thumbBlobs ? await Promise.all(p.thumbBlobs.map(b=>blobToBase64(b))) : null;
    out.push({ id:p.id, title:p.title, body:p.body, tags:p.tags, created_at:p.created_at, category:p.category, authorId:p.authorId||null, authorName:p.authorName||null, anon:p.anon||false, anonPassHash:p.anonPassHash||null, nsfw:!!p.nsfw, mainBase, thumbBase });
  }
  const blob = new Blob([JSON.stringify(out,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='minipix_export.json'; a.click(); URL.revokeObjectURL(url); toast('내보내기 완료');
});
importFile.addEventListener('change', async e=>{
  const f = e.target.files[0]; if(!f) return;
  try{
    const txt = await f.text(); const arr = JSON.parse(txt);
    for(const item of arr){
      const mainBlobs = item.mainBase ? item.mainBase.map(b=>base64ToBlob(b)) : [];
      const thumbBlobs = item.thumbBase ? item.thumbBase.map(b=>base64ToBlob(b)) : [];
      const p = { id: item.id || ('p_'+Date.now()), title: item.title || '', body: item.body || '', tags: item.tags || [], created_at: item.created_at || new Date().toISOString(), category: item.category||'photos', mainBlobs, thumbBlobs, authorId: item.authorId||null, authorName: item.authorName||null, anon: !!item.anon, anonPassHash: item.anonPassHash||null, nsfw: !!item.nsfw };
      await dbPut(p, STORE);
    }
    toast('가져오기 완료'); await renderGallery();
  }catch(err){ console.error(err); toast('가져오기 오류'); } finally { importFile.value=''; }
});
btnClear.addEventListener('click', async ()=>{ if(!confirm('모든 게시물을 삭제합니까?')) return; await dbClear(STORE); toast('모두 삭제됨'); await renderGallery(); });

/* 로그인 / 회원가입 간단 UI (모달 대신 prompt 사용 — 필요하면 모달로 확장) */
loginBtn.addEventListener('click', async ()=>{
  const uname = prompt('아이디'); if(!uname) return;
  const pw = prompt('비밀번호'); if(pw===null) return;
  // authenticate local users
  const user = await getUserByUsername(uname);
  if(!user){ alert('사용자 없음'); return; }
  const h = await hashPassword(pw);
  if(h === user.passwordHash){
    currentUser = { id: user.id, username: user.username, role: user.role };
    saveUserSession(currentUser);
    updateAuthUI();
    toast('로그인 성공');
  } else { alert('로그인 실패'); }
});
registerBtn.addEventListener('click', async ()=>{
  const uname = prompt('원하시는 아이디 (3자 이상 영숫자)'); if(!uname) return;
  const pw = prompt('비밀번호 (4자 이상)'); if(!pw) return;
  try{
    const existing = await getUserByUsername(uname);
    if(existing){ alert('이미 존재하는 아이디'); return; }
    const users = await dbGetAll(USER_STORE);
    const id = 'u_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2,8);
    const role = users.length===0 ? 'admin' : 'user';
    const pHash = await hashPassword(pw);
    const user = { id, username: uname, passwordHash: pHash, role, created_at: new Date().toISOString() };
    await dbPut(user, USER_STORE);
    currentUser = { id: user.id, username: user.username, role: user.role };
    saveUserSession(currentUser);
    updateAuthUI();
    toast('회원가입 및 로그인 완료 (role:'+role+')');
  }catch(err){ alert('회원가입 실패'); console.error(err); }
});
logoutBtn.addEventListener('click', ()=>{ if(!confirm('로그아웃 하시겠어요?')) return; currentUser = null; saveUserSession(null); updateAuthUI(); toast('로그아웃'); });

/* 유저 헬퍼 */
async function getUserByUsername(username){
  const db = await openDB();
  return new Promise((res,rej)=>{
    try{
      const tx = db.transaction(USER_STORE,'readonly');
      const idx = tx.objectStore(USER_STORE).index('username');
      const rq = idx.get(username);
      rq.onsuccess = ()=> res(rq.result || null);
      rq.onerror = ()=> res(null);
    }catch(e){ res(null); }
  });
}

/* 간단 파일/블롭 헬퍼 */
function dataURLtoBlob(dataurl){ const arr=dataurl.split(','), mime=arr[0].match(/:(.*?);/)[1], bstr=atob(arr[1]), n=bstr.length, u8=new Uint8Array(n); for(let i=0;i<n;i++) u8[i]=bstr.charCodeAt(i); return new Blob([u8],{type:mime}); }
function fileToDataUrl(file){ return new Promise((res,rej)=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.onerror=rej; fr.readAsDataURL(file); }); }
function blobToBase64(blob){ return new Promise(res=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result.split(',')[1]); fr.readAsDataURL(blob); }); }
function base64ToBlob(b64, mime='image/jpeg'){ const bin = atob(b64); const len=bin.length; const arr=new Uint8Array(len); for(let i=0;i<len;i++) arr[i]=bin.charCodeAt(i); return new Blob([arr], {type:mime}); }

/* 서버 백업(선택) — 메타데이터 전송 (이미지 블롭 제외, 원하면 서버로 파일 업로드 구현) */
btnBackupNow.addEventListener('click', async ()=>{
  const url = (backupServerInput.value || '').trim();
  if(!url){ toast('백업 서버 URL을 입력하세요'); return; }
  try{
    const posts = await dbGetAll(STORE);
    const payload = posts.map(p=>{ const copy = Object.assign({}, p); copy.mainBlobs = undefined; copy.thumbBlobs = undefined; return copy; });
    const r = await fetch(url.replace(/\/$/,'') + '/backup', { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({posts:payload})});
    if(r.ok) toast('서버 백업 요청 성공');
    else toast('서버 응답 오류: '+r.status);
  }catch(err){ console.error(err); toast('서버 백업 실패 (CORS/네트워크 확인)'); }
});

/* 헬퍼: escape */
function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

</script>
</body>
</html>
