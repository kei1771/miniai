<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="edgeone-site-id" content="kei-">
<meta name="edgeone-cache-buster" content="20231023">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MiniPix — AI 그림 갤러리 (한 파일)</title>
<style>
:root{--bg:#fafbfd;--card:#fff;--muted:#6b7280;--accent:#2b6ef6}
*{box-sizing:border-box}
body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Noto Sans KR',sans-serif;background:var(--bg);color:#111}
.topbar{display:flex;align-items:center;gap:12px;padding:12px 20px;border-bottom:1px solid #eef2ff;background:#fff;position:sticky;top:0;z-index:60}
.brand{font-weight:700;color:var(--accent);text-decoration:none;font-size:16px;cursor:pointer}
.tools{margin-left:auto;display:flex;gap:8px;align-items:center}
.btn{padding:8px 10px;border-radius:8px;border:1px solid #e6e9f2;background:#fff;cursor:pointer}
.btn.primary{background:var(--accent);color:#fff;border:0}
.btn.danger{border-color:#f8d3d3;color:#c53}
.container{max-width:1100px;margin:20px auto;padding:0 16px}
.gallery{display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:14px}
.card{background:#fff;border-radius:12px;overflow:hidden;border:1px solid #f0f3fb;cursor:pointer;position:relative;height:260px;display:flex;flex-direction:column}
.thumb-wrap{flex:1;display:flex;align-items:center;justify-content:center;overflow:hidden;background:#f6f8fb}
.card img.thumb{width:100%;height:100%;object-fit:cover;display:block}
.hover{position:absolute;inset:0;background:linear-gradient(180deg,transparent,rgba(0,0,0,0.35));color:#fff;padding:12px;opacity:0;transition:opacity .18s;display:flex;flex-direction:column;justify-content:flex-end}
.card:hover .hover{opacity:1}
.hover .title{font-weight:600}
.hover .meta{font-size:12px;color:#e6eefc;margin-top:6px}
.empty{text-align:center;color:var(--muted);padding:40px}
.post-page{background:#fff;padding:18px;border-radius:12px;border:1px solid #eef2ff;margin-bottom:40px}
.image-stack{display:flex;flex-direction:column;gap:12px;margin:12px 0}
.image-stack img{width:100%;height:auto;border-radius:8px;display:block}
.post-body{white-space:pre-wrap;color:#222;margin-top:10px}
.tags{margin-top:8px}
.tag{display:inline-block;background:#eef2ff;color:var(--accent);padding:6px 8px;border-radius:6px;margin-right:6px}
.editor{display:flex;flex-direction:column;gap:10px;background:#fff;padding:16px;border-radius:12px;border:1px solid #eef2ff}
input,textarea,select{padding:10px;border-radius:8px;border:1px solid #e6e9f2}
.file{display:inline-block;padding:8px 12px;border-radius:8px;border:1px dashed #dfe7ff;background:#fbfcff;cursor:pointer}
.preview{display:flex;gap:8px;flex-wrap:wrap}
.preview img{width:120px;height:120px;object-fit:cover;border-radius:8px}
.row{display:flex;gap:8px;align-items:center}
.small{font-size:13px;color:var(--muted)}
.controls{display:flex;gap:8px;margin-top:12px}
.toolbar-search{display:flex;gap:8px;align-items:center;background:#fff;padding:6px;border-radius:8px;border:1px solid #eef2ff}
.input-search{padding:8px;border-radius:8px;border:1px solid #e6e9f2}
.carousel-thumbs{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
.carousel-thumbs img{width:72px;height:72px;object-fit:cover;border-radius:6px;cursor:pointer;border:2px solid transparent}
.carousel-thumbs img.active{border-color:var(--accent)}
.user-badge{display:flex;align-items:center;gap:8px;padding:6px 8px;border-radius:8px;background:#f6f8ff;border:1px solid #e6eefc;color:var(--muted)}
.settings-modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:none;align-items:center;justify-content:center;z-index:220}
.settings-modal{background:#fff;padding:18px;border-radius:12px;box-shadow:0 12px 40px rgba(0,0,0,0.25);max-width:520px}
.login-modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:none;align-items:center;justify-content:center;z-index:220}
.login-modal{background:#fff;padding:18px;border-radius:12px;box-shadow:0 12px 40px rgba(0,0,0,0.25);max-width:420px}
.copy-modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:none;align-items:center;justify-content:center;z-index:200}
.copy-modal{background:#fff;padding:18px;border-radius:12px;box-shadow:0 12px 40px rgba(0,0,0,0.25);max-width:420px;text-align:center}
.copy-modal h4{margin:0 0 8px;font-size:16px}
.copy-modal p{margin:0 0 12px;color:var(--muted)}
.copy-modal .btn{padding:8px 12px}
@media (max-width:720px){ .card{height:200px} .preview img{width:88px;height:88px} .copy-modal{width:90%;} }
</style>
</head>
<body>
  <header class="topbar">
    <div class="brand" id="brand">MiniPix — AI 그림 갤러리</div>
    <div class="tools">
      <div class="toolbar-search">
        <input id="search" class="input-search" placeholder="검색 (제목/본문/태그)" />
        <select id="sort" class="input-search" style="width:120px">
          <option value="desc">최신순</option>
          <option value="asc">오래된순</option>
        </select>
        <select id="filter" class="input-search" style="width:140px">
          <option value="all">전체</option>
          <option value="photos">사진</option>
          <option value="text">글</option>
          <option value="memo">메모</option>
        </select>
      </div>

      <div id="userArea" class="user-badge" style="display:none">
        <span id="userName">Guest</span>
        <button id="logoutBtn" class="btn">로그아웃</button>
      </div>

      <button id="loginBtn" class="btn">로그인</button>
      <button id="registerBtn" class="btn">회원가입</button>
      <button id="settingsBtn" class="btn">설정</button>

      <button id="btnNew" class="btn primary">새 글 올리기</button>
      <button id="btnExport" class="btn">내보내기</button>
      <label class="btn file">가져오기<input id="importFile" type="file" accept="application/json" style="display:none" /></label>
      <button id="btnClear" class="btn">전체 삭제</button>
    </div>
  </header>

  <main class="container" id="app">
    <section id="gallery" class="gallery"></section>
    <div id="empty" class="empty" style="display:none">게시물이 없습니다. '새 글 올리기'로 시작하세요.</div>
  </main>

  <!-- Editor Modal -->
  <div id="editorModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.45);align-items:center;justify-content:center;padding:20px;z-index:120">
    <div style="width:100%;max-width:920px;background:#fff;border-radius:10px;padding:14px;max-height:90vh;overflow:auto;position:relative">
      <button id="editorClose" style="position:absolute;right:12px;top:12px;border:0;background:#fff;padding:6px;border-radius:6px;cursor:pointer">✕</button>
      <h3 id="editorTitle">새 글 올리기</h3>
      <form id="editorForm" class="editor" onsubmit="return false;">
        <input id="title" placeholder="제목 (선택)" />
        <textarea id="body" rows="8" placeholder="본문"></textarea>

        <div class="row">
          <label class="file">이미지 선택<input id="files" type="file" accept="image/*" multiple style="display:none" /></label>
          <div id="selectedNames" class="small" style="margin-left:8px">선택된 파일 없음</div>
          <div style="margin-left:auto" class="small">최대 200장 권장 • EXIF 제거</div>
        </div>

        <div class="preview" id="preview"></div>

        <input id="tags" placeholder="태그 (쉼표 구분)" />
        <div class="row">
          <select id="category"><option value="photos">사진</option><option value="text">글</option><option value="memo">메모</option></select>
          <div style="margin-left:auto;display:flex;gap:8px">
            <button id="btnSave" class="btn primary">저장</button>
            <button id="btnSaveClose" class="btn">저장 후 닫기</button>
          </div>
        </div>

        <!-- anonymous delete password (required for anonymous posts) -->
        <div id="anonPassRow" style="display:none">
          <label class="small">익명 삭제용 비밀번호 (필수 - 익명 업로드 시)</label>
          <input id="anonPassword" placeholder="익명 글 삭제용 비밀번호" type="password" />
        </div>

        <div id="editorProgress" class="small" style="margin-top:8px"></div>
      </form>
    </div>
  </div>

  <!-- Post View -->
  <div id="postView" style="display:none;padding:20px;max-width:900px;margin:20px auto;z-index:30">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <h2 id="postTitleView">제목</h2>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="btnBack" class="btn">목록</button>
        <button id="btnEditPost" class="btn">편집</button>
        <button id="btnDeletePost" class="btn danger">삭제</button>
      </div>
    </div>

    <div class="post-page" id="postContent">
      <div id="metaView" class="small" style="color:var(--muted)"></div>
      <div class="image-stack" id="imageStack"></div>
      <div id="carouselThumbs" class="carousel-thumbs" style="display:none"></div>
      <div id="postBody" class="post-body"></div>
      <div id="postTags" class="tags"></div>
      <div style="margin-top:12px;display:flex;gap:8px;align-items:center">
        <a id="downloadLink" class="btn" href="#" download>원본 다운로드</a>
        <button id="copyBodyBtn" class="btn">본문 복사</button>
        <button id="bulkDownloadBtn" class="btn">일괄 다운로드</button>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settingsBackdrop" class="settings-modal-backdrop">
    <div class="settings-modal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
      <h3 id="settingsTitle">설정</h3>
      <div style="display:flex;flex-direction:column;gap:10px;margin-top:8px">
        <label><input id="optAllowAnon" type="checkbox"> 익명 업로드 허용</label>
        <label><input id="optRequireMember" type="checkbox"> 회원 전용 모드 (활성 시 비회원은 업로드 불가)</label>
        <label><input id="optAllowNSFW" type="checkbox"> NSFW 업로드 허용</label>
        <div class="small">회원은 역할(일반/관리자)을 가질 수 있으며, 관리자는 모든 게시물을 삭제할 수 있습니다.</div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px">
          <button id="settingsClose" class="btn">닫기</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Login / Register Modal -->
  <div id="loginBackdrop" class="login-modal-backdrop">
    <div class="login-modal" role="dialog" aria-modal="true" aria-labelledby="loginTitle">
      <h3 id="loginTitle">로그인 / 회원가입</h3>
      <div style="display:flex;flex-direction:column;gap:8px;margin-top:8px">
        <input id="authUsername" placeholder="아이디 (영문/숫자 추천)" />
        <input id="authPassword" placeholder="비밀번호" type="password" />
        <div style="display:flex;gap:8px;justify-content:flex-end">
          <button id="doRegister" class="btn">회원가입</button>
          <button id="doLogin" class="btn primary">로그인</button>
        </div>
        <div id="authMsg" class="small" style="color:var(--muted)"></div>
        <div style="font-size:12px;color:var(--muted);margin-top:6px">
          첫 가입자는 자동으로 관리자(admin) 권한이 부여됩니다. (로컬 환경 전용)
        </div>
      </div>
    </div>
  </div>

  <!-- Copy confirmation modal -->
  <div id="copyModalBackdrop" class="copy-modal-backdrop" >
    <div class="copy-modal" role="dialog" aria-modal="true" aria-labelledby="copyModalTitle">
      <h4 id="copyModalTitle">복사 완료!</h4>
      <p>본문이 클립보드에 복사되었습니다.</p>
      <div style="display:flex;justify-content:center"><button id="copyModalOk" class="btn primary">확인</button></div>
    </div>
  </div>


  <!-- JSZip: 일괄 다운로드용 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>
/* Single-file MiniPix app with:
   - IndexedDB storage (posts + users)
   - Simple local member system (signup/login) with SHA-256 password hashing
   - Anonymous posts allowed (configurable) but require deletion password
   - Member-only mode (configurable)
   - NSFW toggle (stored, but NSFW flag not used except as placeholder)
   - Post deletion rules: members can delete their posts; admins can delete any; anonymous posts delete with password
   - Other existing features (export/import, ZIP bulk download, copy modal)
*/

// ---- config ----
const DB_NAME = 'minipix-db-v2';
const STORE = 'posts';
const USER_STORE = 'users';
const DB_VERSION = 3; // bumped to create users store
const MAX_FILES = 200;
const THUMB_SIZE = 400;
const MAX_MAIN_WIDTH = 1920;
const IMAGE_MIME = 'image/jpeg';
const IMAGE_QUALITY = 0.85;

// ---- app state ----
let currentUser = null; // { id, username, role }
let settings = {
  allowAnon: true,
  allowNSFW: false,
  requireMember: false
};

// load settings from localStorage
try { const s = JSON.parse(localStorage.getItem('minipix_settings')||'{}'); settings = Object.assign(settings, s); } catch(e){}

function saveSettings(){ localStorage.setItem('minipix_settings', JSON.stringify(settings)); updateSettingsUI(); }

// ---- indexedDB helpers ----
function openDB(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = e => {
      const db = e.target.result;
      if(!db.objectStoreNames.contains(STORE)){
        const os = db.createObjectStore(STORE,{keyPath:'id'});
        os.createIndex('created_at','created_at',{unique:false});
      }
      if(!db.objectStoreNames.contains(USER_STORE)){
        const us = db.createObjectStore(USER_STORE,{keyPath:'id'});
        us.createIndex('username','username',{unique:true});
      }
    };
    req.onsuccess = e => resolve(e.target.result);
    req.onerror = e => reject(e.target.error);
  });
}
async function dbPut(obj, store=STORE){
  const db = await openDB();
  return new Promise((res,rej)=>{
    const tx = db.transaction(store,'readwrite');
    tx.objectStore(store).put(obj);
    tx.oncomplete = ()=> res(obj);
    tx.onerror = e => rej(e.target.error);
  });
}
async function dbGetAll(store=STORE){
  const db = await openDB();
  return new Promise((res,rej)=>{
    const tx = db.transaction(store,'readonly');
    const r = tx.objectStore(store).getAll();
    r.onsuccess = ()=> res(r.result || []);
    r.onerror = e => rej(e.target.error);
  });
}
async function dbGet(id, store=STORE){
  const db = await openDB();
  return new Promise((res,rej)=>{
    const tx = db.transaction(store,'readonly');
    const r = tx.objectStore(store).get(id);
    r.onsuccess = ()=> res(r.result);
    r.onerror = e => rej(e.target.error);
  });
}
async function dbDelete(id, store=STORE){
  const db = await openDB();
  return new Promise((res,rej)=>{
    const tx = db.transaction(store,'readwrite');
    tx.objectStore(store).delete(id);
    tx.oncomplete = ()=> res();
    tx.onerror = e => rej(e.target.error);
  });
}
async function dbClear(store=STORE){
  const db = await openDB();
  return new Promise((res,rej)=>{
    const tx = db.transaction(store,'readwrite');
    tx.objectStore(store).clear();
    tx.oncomplete = ()=> res();
    tx.onerror = e => rej(e.target.error);
  });
}

// ---- utils ----
function uid(){ return 'p_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2,8); }
function qs(sel, ctx=document){ return ctx.querySelector(sel); }
function qsa(sel, ctx=document){ return Array.from((ctx||document).querySelectorAll(sel)); }
function toast(msg, timeout=1600){
  const el = document.createElement('div');
  el.textContent = msg;
  el.style.position='fixed'; el.style.right='18px'; el.style.bottom='18px';
  el.style.background='#111'; el.style.color='#fff'; el.style.padding='10px 14px';
  el.style.borderRadius='8px'; el.style.zIndex=9999; document.body.appendChild(el);
  setTimeout(()=>el.remove(), timeout);
}
function formatDate(iso){ return new Date(iso).toLocaleString(); }

// manage object URLs (avoid leaks)
const _urls = new Set();
function makeURL(blob){ if(!blob) return null; const u = URL.createObjectURL(blob); _urls.add(u); return u; }
function revokeAllURLs(){ _urls.forEach(u=>{ try{ URL.revokeObjectURL(u); }catch(_){} }); _urls.clear(); }

// ---- image processing ----
function readFileAsImage(file){
  return new Promise((res, rej)=>{
    const fr = new FileReader();
    fr.onload = () => {
      const img = new Image();
      img.onload = ()=> res(img);
      img.onerror = rej;
      img.src = fr.result;
    };
    fr.onerror = rej;
    fr.readAsDataURL(file);
  });
}
async function processImage(img, maxWidth=MAX_MAIN_WIDTH, thumbSize=THUMB_SIZE, mime=IMAGE_MIME, quality=IMAGE_QUALITY){
  // main
  const ratio = Math.min(1, maxWidth / img.width);
  const w = Math.round(img.width * ratio), h = Math.round(img.height * ratio);
  const c = document.createElement('canvas'); c.width = w; c.height = h;
  const ctx = c.getContext('2d'); ctx.drawImage(img, 0, 0, w, h);
  const mainBlob = await new Promise(r => c.toBlob(r, mime, quality));

  // thumbnail (cover center)
  const scale = Math.max(thumbSize / img.width, thumbSize / img.height);
  const sw = Math.round(img.width * scale), sh = Math.round(img.height * scale);
  const tmp = document.createElement('canvas'); tmp.width = sw; tmp.height = sh;
  const tctx = tmp.getContext('2d'); tctx.drawImage(img, 0, 0, sw, sh);
  const sx = Math.max(0, Math.round((sw - thumbSize) / 2)), sy = Math.max(0, Math.round((sh - thumbSize) / 2));
  const t = document.createElement('canvas'); t.width = thumbSize; t.height = thumbSize;
  t.getContext('2d').drawImage(tmp, sx, sy, thumbSize, thumbSize, 0, 0, thumbSize, thumbSize);
  const thumbBlob = await new Promise(r => t.toBlob(r, mime, quality));
  return { mainBlob, thumbBlob, width: img.width, height: img.height };
}

// ---- elements ----
const galleryEl = qs('#gallery');
const emptyEl = qs('#empty');
const brand = qs('#brand');
const searchInput = qs('#search');
const sortSelect = qs('#sort');
const filterSelect = qs('#filter');
const btnNew = qs('#btnNew');
const btnExport = qs('#btnExport');
const importFile = qs('#importFile');
const btnClear = qs('#btnClear');

const editorModal = qs('#editorModal');
const editorClose = qs('#editorClose');
const editorForm = qs('#editorForm');
const filesInput = qs('#files');
const selectedNames = qs('#selectedNames');
const previewEl = qs('#preview');
const titleInput = qs('#title');
const bodyInput = qs('#body');
const tagsInput = qs('#tags');
const categoryInput = qs('#category');
const btnSave = qs('#btnSave');
const btnSaveClose = qs('#btnSaveClose');
const editorProgress = qs('#editorProgress');
const anonPassRow = qs('#anonPassRow');
const anonPasswordInput = qs('#anonPassword');

const postView = qs('#postView');
const postTitleView = qs('#postTitleView');
const metaView = qs('#metaView');
const imageStack = qs('#imageStack');
const carouselThumbs = qs('#carouselThumbs');
const postBodyEl = qs('#postBody');
const postTagsEl = qs('#postTags');
const btnBack = qs('#btnBack');
const btnEditPost = qs('#btnEditPost');
const btnDeletePost = qs('#btnDeletePost');
const downloadLink = qs('#downloadLink');
const copyBodyBtn = qs('#copyBodyBtn');

const copyModalBackdrop = qs('#copyModalBackdrop');
const copyModalOk = qs('#copyModalOk');

const settingsBackdrop = qs('#settingsBackdrop');
const settingsClose = qs('#settingsClose');
const settingsBtn = qs('#settingsBtn');
const optAllowAnon = qs('#optAllowAnon');
const optAllowNSFW = qs('#optAllowNSFW');
const optRequireMember = qs('#optRequireMember');

const loginBackdrop = qs('#loginBackdrop');
const loginBtn = qs('#loginBtn');
const registerBtn = qs('#registerBtn');
const doLogin = qs('#doLogin');
const doRegister = qs('#doRegister');
const authUsername = qs('#authUsername');
const authPassword = qs('#authPassword');
const authMsg = qs('#authMsg');
const userArea = qs('#userArea');
const userName = qs('#userName');
const logoutBtn = qs('#logoutBtn');

let cachedPosts = [];
let currentPostId = null;
let editMode = false;
let editingId = null;

// ---- password hashing (SHA-256 hex) ----
async function hashPassword(password){
  const enc = new TextEncoder();
  const buf = await crypto.subtle.digest('SHA-256', enc.encode(password || ''));
  return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
}

// ---- user management ----
async function createUser(username, password){
  username = String(username||'').trim();
  if(!username || !password) throw new Error('아이디/비밀번호 필요');
  // ensure unique
  const existing = await getUserByUsername(username);
  if(existing) throw new Error('이미 존재하는 아이디입니다');
  const id = 'u_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2,8);
  const isFirst = (await dbGetAll(USER_STORE)).length === 0;
  const role = isFirst ? 'admin' : 'user';
  const pHash = await hashPassword(password);
  const user = { id, username, passwordHash: pHash, role, created_at: new Date().toISOString() };
  await dbPut(user, USER_STORE);
  return user;
}
async function getUserByUsername(username){
  const db = await openDB();
  return new Promise((res, rej) => {
    try{
      const tx = db.transaction(USER_STORE,'readonly');
      const idx = tx.objectStore(USER_STORE).index('username');
      const rq = idx.get(username);
      rq.onsuccess = ()=> res(rq.result || null);
      rq.onerror = ()=> res(null);
    } catch(e){ res(null); }
  });
}
async function authenticateUser(username, password){
  const u = await getUserByUsername(username);
  if(!u) return null;
  const pHash = await hashPassword(password);
  if(pHash === u.passwordHash) return { id: u.id, username: u.username, role: u.role };
  return null;
}
function setCurrentUser(user){
  currentUser = user;
  if(user){
    userArea.style.display = 'flex';
    userName.textContent = user.username + (user.role === 'admin' ? ' (관리자)' : '');
    loginBtn.style.display = 'none';
    registerBtn.style.display = 'none';
  } else {
    userArea.style.display = 'none';
    loginBtn.style.display = 'inline-block';
    registerBtn.style.display = 'inline-block';
  }
  updateEditorAnonRow();
  updateNewButtonState();
}
logoutBtn.addEventListener('click', ()=> {
  setCurrentUser(null);
  toast('로그아웃되었습니다');
});

// ---- boot ----
(async function boot(){
  await openDB();
  attachEvents();
  updateSettingsUI();
  loadInitialUserState();
  routeFromLocation();
})();

function loadInitialUserState(){
  const raw = localStorage.getItem('minipix_current_user');
  if(raw){
    try{ setCurrentUser(JSON.parse(raw)); } catch(e){ setCurrentUser(null); }
  } else {
    setCurrentUser(null);
  }
}
function persistUserState(){
  if(currentUser) localStorage.setItem('minipix_current_user', JSON.stringify(currentUser));
  else localStorage.removeItem('minipix_current_user');
}

function routeFromLocation(){
  const params = new URLSearchParams(location.search);
  const view = params.get('view');
  const id = params.get('id');
  if(view === 'post' && id){
    showPostView(id, false);
  } else {
    showGallery(false);
  }
}

// ---- navigation helpers ----
function goHome(push=true){
  if(push) history.pushState({}, '', location.pathname);
  showGallery(true);
}
function goPost(id, push=true){
  if(push) history.pushState({}, '', `${location.pathname}?view=post&id=${encodeURIComponent(id)}`);
  showPostView(id, true);
}
window.addEventListener('popstate', ()=> routeFromLocation());

// ---- gallery ----
async function showGallery(scrollTop=true){
  postView.style.display = 'none';
  editorModal.style.display = 'none';
  await renderGallery();
  if(scrollTop) window.scrollTo({top:0,behavior:'instant'});
}

async function renderGallery(){
  revokeAllURLs();
  const posts = await dbGetAll(STORE);
  cachedPosts = posts.sort((a,b)=> sortSelect.value === 'desc' ? b.created_at.localeCompare(a.created_at) : a.created_at.localeCompare(b.created_at));
  const q = (searchInput.value||'').trim().toLowerCase();
  const cat = filterSelect.value;
  let visible = cachedPosts.filter(p=>{
    if(cat !== 'all' && p.category !== cat) return false;
    if(!q) return true;
    return (p.title||'').toLowerCase().includes(q) || (p.body||'').toLowerCase().includes(q) || (p.tags||[]).join(' ').toLowerCase().includes(q);
  });

  galleryEl.innerHTML = '';
  if(!visible.length){ emptyEl.style.display = 'block'; galleryEl.style.display='none'; return; }
  else { emptyEl.style.display = 'none'; galleryEl.style.display='grid'; }

  visible.forEach(p => {
    const card = document.createElement('div'); card.className='card';
    const wrap = document.createElement('div'); wrap.className='thumb-wrap';
    const img = document.createElement('img'); img.className='thumb';
    if(p.thumbBlobs && p.thumbBlobs.length) img.src = makeURL(p.thumbBlobs[0]);
    else img.src = 'data:image/svg+xml;utf8,'+encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="600" height="400"><rect width="100%" height="100%" fill="#f6f7fb"/></svg>');
    wrap.appendChild(img);
    const hover = document.createElement('div'); hover.className='hover';
    const author = p.authorName ? escapeHtml(p.authorName) : (p.anon ? '익명' : '비회원');
    hover.innerHTML = `<div class="title">${p.title?escapeHtml(p.title):'(제목없음)'}</div><div class="meta">${(p.tags||[]).slice(0,3).join(' · ')} · ${author} · ${new Date(p.created_at).toLocaleString()}</div>`;
    card.appendChild(wrap); card.appendChild(hover);
    card.addEventListener('click', ()=> goPost(p.id));
    galleryEl.appendChild(card);
  });
}

// ---- post view ----
async function showPostView(id, scrollTop){
  editorModal.style.display = 'none';
  const post = await dbGet(id);
  if(!post){ toast('게시물을 찾을 수 없습니다.'); goHome(); return; }
  currentPostId = id;
  postTitleView.textContent = post.title || '(제목없음)';
  const author = post.authorName ? post.authorName : (post.anon ? '익명' : '비회원');
  metaView.textContent = `${new Date(post.created_at).toLocaleString()} · ${post.category||''} · ${author}`;
  imageStack.innerHTML = ''; carouselThumbs.innerHTML = ''; carouselThumbs.style.display='none';
  if(post.mainBlobs && post.mainBlobs.length){
    post.mainBlobs.forEach((b, idx) => {
      const img = document.createElement('img'); img.src = makeURL(b); img.style.width='100%'; img.style.height='auto';
      imageStack.appendChild(img);
      // thumbs
      const t = document.createElement('img'); t.src = makeURL((post.thumbBlobs && post.thumbBlobs[idx]) ? post.thumbBlobs[idx] : b);
      t.addEventListener('click', ()=> { img.scrollIntoView({behavior:'smooth', block:'center'}); });
      carouselThumbs.appendChild(t);
    });
    if(carouselThumbs.children.length) carouselThumbs.style.display='flex';
  }
  postBodyEl.textContent = post.body || '';
  postTagsEl.innerHTML = '';
  (post.tags || []).forEach(t => { const sp = document.createElement('span'); sp.className='tag'; sp.textContent = t; postTagsEl.appendChild(sp); });
  downloadLink.href = (post.mainBlobs && post.mainBlobs[0]) ? makeURL(post.mainBlobs[0]) : '#';
  downloadLink.download = (post.title?post.title.replace(/\s+/g,'_'):'image') + '.jpg';

  document.getElementById('gallery').style.display = 'none';
  emptyEl.style.display = 'none';
  postView.style.display = 'block';
  if(scrollTop) window.scrollTo({top:0,behavior:'instant'});
}

// ---- editor ----
function openEditor(opts={mode:'new', id:null}){
  editMode = opts.mode === 'edit';
  editingId = opts.id || null;
  previewEl.innerHTML = ''; filesInput.value = ''; selectedNames.textContent = '선택된 파일 없음'; editorProgress.textContent = '';
  anonPasswordInput.value = '';
  if(editMode){ editorFormResetForEdit(editingId); qs('#editorTitle').textContent = '게시물 편집'; }
  else { qs('#editorTitle').textContent = '새 글 올리기'; titleInput.value=''; bodyInput.value=''; tagsInput.value=''; categoryInput.value='photos'; }
  editorModal.style.display = 'flex';
  window.scrollTo({top:0,behavior:'instant'});
}
async function editorFormResetForEdit(id){
  const post = await dbGet(id);
  if(!post) return;
  titleInput.value = post.title || '';
  bodyInput.value = post.body || '';
  tagsInput.value = (post.tags||[]).join(', ');
  categoryInput.value = post.category || 'photos';
  previewEl.innerHTML = '';
  (post.thumbBlobs || []).forEach(b => { const img = document.createElement('img'); img.src = makeURL(b); previewEl.appendChild(img); });
}

filesInput.addEventListener('change', ()=>{
  const files = Array.from(filesInput.files || []);
  if(!files.length){ selectedNames.textContent = '선택된 파일 없음'; previewEl.innerHTML=''; return; }
  const slice = files.slice(0, MAX_FILES);
  selectedNames.textContent = slice.map(f=>f.name).join(', ').slice(0,200);
  previewEl.innerHTML = '';
  slice.forEach(f => {
    const url = URL.createObjectURL(f);
    previewEl.appendChild(Object.assign(document.createElement('img'), {src:url}));
    _urls.add(url);
  });
});

editorClose.addEventListener('click', ()=> { editorModal.style.display='none'; });
btnNew.addEventListener('click', ()=>{
  if(settings.requireMember && !currentUser){
    toast('회원 전용 모드입니다. 먼저 로그인하세요.');
    return;
  }
  if(!settings.allowAnon && !currentUser){
    toast('익명 업로드가 비활성화되어 있습니다. 로그인하세요.');
    return;
  }
  openEditor({mode:'new'});
});
btnSave.addEventListener('click', ()=> editorSave(false));
btnSaveClose.addEventListener('click', ()=> editorSave(true));

async function editorSave(closeAfter){
  // If anonymous uploader must provide a deletion password
  if(!currentUser && settings.allowAnon){
    if(!anonPasswordInput.value || String(anonPasswordInput.value).trim().length < 4){
      toast('익명 업로드 시 삭제용 비밀번호(최소 4자)를 입력하세요.');
      return;
    }
  }
  editorProgress.textContent = '이미지 처리 중...';
  try{
    const files = Array.from(filesInput.files || []).slice(0, MAX_FILES);
    const mainBlobs = []; const thumbBlobs = [];
    for(const f of files){
      if(!f.type.startsWith('image/')) continue;
      const img = await readFileAsImage(f);
      const { mainBlob, thumbBlob } = await processImage(img);
      mainBlobs.push(mainBlob); thumbBlobs.push(thumbBlob);
    }

    let post = {};
    if(editMode && editingId){ post = await dbGet(editingId) || {}; }
    else { post.id = uid(); post.created_at = new Date().toISOString(); }

    post.title = titleInput.value.trim();
    post.body = bodyInput.value.trim();
    post.tags = (tagsInput.value||'').split(',').map(s=>s.trim()).filter(Boolean);
    post.category = categoryInput.value || 'photos';

    if(currentUser){
      post.authorId = currentUser.id;
      post.authorName = currentUser.username;
      post.anon = false;
      // remove anon password if exists
      delete post.anonPassHash;
    } else {
      // anonymous - require password (already validated)
      post.anon = true;
      post.authorId = null;
      post.authorName = null;
      post.anonPassHash = await hashPassword(String(anonPasswordInput.value||''));
    }

    if(mainBlobs.length){
      post.mainBlobs = (post.mainBlobs || []).concat(mainBlobs);
      post.thumbBlobs = (post.thumbBlobs || []).concat(thumbBlobs);
    }
    await dbPut(post);
    toast(editMode ? '저장되었습니다' : '업로드 완료');
    editorProgress.textContent = ''; editorModal.style.display = 'none';
    persistUserState();
    if(closeAfter) goPost(post.id); else goHome();
    await renderGallery();
  } catch(err){
    console.error(err); editorProgress.textContent=''; toast('업로드 중 오류가 발생했습니다.');
  }
}

// ---- post actions ----
btnBack.addEventListener('click', ()=> goHome());
btnEditPost.addEventListener('click', async ()=> {
  if(!currentPostId) return;
  const post = await dbGet(currentPostId);
  if(!post) return;
  // allow edit only to the owner (member) for now, or admin
  if(post.authorId){
    if(!currentUser || (currentUser.id !== post.authorId && currentUser.role !== 'admin')) {
      return toast('편집 권한이 없습니다.');
    }
  } else {
    // anonymous posts cannot be edited in this simple implementation
    return toast('익명 게시물은 편집할 수 없습니다.');
  }
  editorModal.style.display='none'; openEditor({mode:'edit', id: currentPostId});
});

btnDeletePost.addEventListener('click', async ()=> {
  if(!currentPostId) return;
  const post = await dbGet(currentPostId);
  if(!post) return toast('게시물을 찾을 수 없습니다.');

  // if post has authorId (member post)
  if(post.authorId){
    if(currentUser && (currentUser.id === post.authorId || currentUser.role === 'admin')){
      if(!confirm('정말 삭제하시겠습니까?')) return;
      await dbDelete(currentPostId);
      toast('삭제되었습니다');
      goHome();
      await renderGallery();
      return;
    } else {
      return toast('삭제 권한이 없습니다.');
    }
  }

  // anonymous post: prompt for password
  if(post.anon){
    const pw = prompt('삭제를 위해 익명 작성 시 입력한 비밀번호를 입력하세요.');
    if(pw === null) return;
    const h = await hashPassword(String(pw));
    if(h === post.anonPassHash){
      if(!confirm('정말 삭제하시겠습니까?')) return;
      await dbDelete(currentPostId);
      toast('삭제되었습니다');
      goHome();
      await renderGallery();
    } else {
      toast('비밀번호가 틀렸습니다.');
    }
    return;
  }

  // fallback: if no author and not anon (older imports), guard by admin only
  if(currentUser && currentUser.role === 'admin'){
    if(!confirm('정말 삭제하시겠습니까?')) return;
    await dbDelete(currentPostId);
    toast('삭제되었습니다 (관리자)');
    goHome();
    await renderGallery();
  } else {
    toast('삭제 권한이 없습니다.');
  }
});

// ---- export / import / clear ----
btnExport.addEventListener('click', async ()=>{
  const posts = await dbGetAll(STORE);
  const out = [];
  for(const p of posts){
    const mainBase = p.mainBlobs ? await Promise.all(p.mainBlobs.map(b=>blobToBase64(b))) : null;
    const thumbBase = p.thumbBlobs ? await Promise.all(p.thumbBlobs.map(b=>blobToBase64(b))) : null;
    out.push({ id:p.id, title:p.title, body:p.body, tags:p.tags, created_at:p.created_at, category:p.category, authorId:p.authorId||null, authorName:p.authorName||null, anon:p.anon||false, anonPassHash:p.anonPassHash||null, mainBase, thumbBase });
  }
  const blob = new Blob([JSON.stringify(out, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'minipix_export.json'; a.click(); URL.revokeObjectURL(url);
  toast('내보내기 완료');
});
importFile.addEventListener('change', async e=>{
  const f = e.target.files[0]; if(!f) return;
  try{
    const txt = await f.text(); const arr = JSON.parse(txt);
    for(const item of arr){
      const mainBlobs = item.mainBase ? item.mainBase.map(b=>base64ToBlob(b)) : [];
      const thumbBlobs = item.thumbBase ? item.thumbBase.map(b=>base64ToBlob(b)) : [];
      const p = { id: item.id || uid(), title: item.title || '', body: item.body || '', tags: item.tags || [], created_at: item.created_at || new Date().toISOString(), category: item.category || 'photos', mainBlobs, thumbBlobs };
      // preserve author info if present
      if(item.authorId) p.authorId = item.authorId;
      if(item.authorName) p.authorName = item.authorName;
      if(item.anon) { p.anon = true; p.anonPassHash = item.anonPassHash || null; }
      await dbPut(p);
    }
    toast('가져오기 완료'); await renderGallery();
  } catch(err){ console.error(err); toast('가져오기 오류'); } finally { importFile.value=''; }
});
btnClear.addEventListener('click', async ()=> { if(!confirm('정말 모든 게시물을 삭제합니까? (주의)')) return; await dbClear(STORE); revokeAllURLs(); toast('모두 삭제됨'); await renderGallery(); });

// ---- copy body button & confirmation modal logic ----
copyBodyBtn.addEventListener('click', async ()=>{
  if(!currentPostId) return;
  const post = await dbGet(currentPostId);
  if(!post) return toast('게시물을 찾을 수 없습니다.');
  const text = post.body || '';
  try{
    if(navigator.clipboard && navigator.clipboard.writeText){
      await navigator.clipboard.writeText(text);
    } else {
      // fallback
      const ta = document.createElement('textarea'); ta.value = text; document.body.appendChild(ta); ta.select();
      try { document.execCommand('copy'); } catch(e){ console.error(e); }
      ta.remove();
    }
    showCopyModal();
  } catch(err){
    console.error(err);
    toast('복사에 실패했습니다.');
  }
});

function showCopyModal(){
  copyModalBackdrop.style.display = 'flex';
  // attach events to close
  function onClickBackdrop(e){ if(e.target === copyModalBackdrop){ hideCopyModal(); } }
  function onKey(e){ if(e.key === 'Escape'){ hideCopyModal(); } }
  copyModalBackdrop.addEventListener('click', onClickBackdrop);
  window.addEventListener('keydown', onKey);
  copyModalOk.focus();
  // cleanup when closed
  copyModalBackdrop._cleanup = ()=>{ copyModalBackdrop.removeEventListener('click', onClickBackdrop); window.removeEventListener('keydown', onKey); };
}

function hideCopyModal(){
  copyModalBackdrop.style.display = 'none';
  if(copyModalBackdrop._cleanup) copyModalBackdrop._cleanup();
}
copyModalOk.addEventListener('click', hideCopyModal);

// ---- helpers ----
function blobToBase64(blob){
  return new Promise(res=>{ const fr = new FileReader(); fr.onload = ()=> res(fr.result.split(',')[1]); fr.readAsDataURL(blob); });
}
function base64ToBlob(b64, mime='image/jpeg'){
  const bin = atob(b64); const len = bin.length; const arr = new Uint8Array(len);
  for(let i=0;i<len;i++) arr[i] = bin.charCodeAt(i);
  return new Blob([arr], { type: mime });
}
function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

// ---- settings UI ----
function updateSettingsUI(){
  optAllowAnon.checked = !!settings.allowAnon;
  optAllowNSFW.checked = !!settings.allowNSFW;
  optRequireMember.checked = !!settings.requireMember;
  updateEditorAnonRow();
  updateNewButtonState();
}
settingsBtn.addEventListener('click', ()=> { settingsBackdrop.style.display = 'flex'; });
settingsClose.addEventListener('click', ()=> { settingsBackdrop.style.display = 'none'; saveSettings(); });
optAllowAnon.addEventListener('change', ()=> { settings.allowAnon = optAllowAnon.checked; saveSettings(); });
optAllowNSFW.addEventListener('change', ()=> { settings.allowNSFW = optAllowNSFW.checked; saveSettings(); });
optRequireMember.addEventListener('change', ()=> { settings.requireMember = optRequireMember.checked; saveSettings(); });

function updateEditorAnonRow(){
  // show anon password row only when creating posts as anonymous
  if(!currentUser && settings.allowAnon){
    anonPassRow.style.display = 'block';
  } else {
    anonPassRow.style.display = 'none';
  }
}
function updateNewButtonState(){
  if(settings.requireMember && !currentUser){
    btnNew.disabled = true;
    btnNew.title = '회원 전용 모드입니다. 로그인 필요';
  } else if(!settings.allowAnon && !currentUser){
    btnNew.disabled = false;
    btnNew.title = '익명 업로드 불가: 로그인 필요';
  } else {
    btnNew.disabled = false;
    btnNew.title = '';
  }
}

// ---- auth modal actions ----
loginBtn.addEventListener('click', ()=> { authMsg.textContent=''; authUsername.value=''; authPassword.value=''; loginBackdrop.style.display='flex'; });
registerBtn.addEventListener('click', ()=> { authMsg.textContent=''; authUsername.value=''; authPassword.value=''; loginBackdrop.style.display='flex'; });

doRegister.addEventListener('click', async ()=>{
  const username = String(authUsername.value||'').trim();
  const password = String(authPassword.value||'');
  try{
    if(username.length < 3 || password.length < 4) { authMsg.textContent = '아이디는 3자 이상, 비밀번호는 4자 이상 필요합니다.'; return; }
    const user = await createUser(username, password);
    setCurrentUser({ id: user.id, username: user.username, role: user.role });
    persistUserState();
    loginBackdrop.style.display='none';
    toast('회원가입 및 로그인 완료');
  } catch(err){
    authMsg.textContent = err.message || '회원가입 실패';
  }
});

doLogin.addEventListener('click', async ()=>{
  const username = String(authUsername.value||'').trim();
  const password = String(authPassword.value||'');
  try{
    const user = await authenticateUser(username, password);
    if(!user){ authMsg.textContent = '아이디 또는 비밀번호가 올바르지 않습니다.'; return; }
    setCurrentUser(user);
    persistUserState();
    loginBackdrop.style.display='none';
    toast('로그인 완료');
  } catch(err){
    authMsg.textContent = '로그인 실패';
  }
});

// close login modal by clicking backdrop
loginBackdrop.addEventListener('click', (e)=>{ if(e.target === loginBackdrop) loginBackdrop.style.display='none'; });
settingsBackdrop.addEventListener('click', (e)=>{ if(e.target === settingsBackdrop) settingsBackdrop.style.display='none'; });

// ---- events attach ----
function attachEvents(){
  brand.addEventListener('click', e=>{ e.preventDefault(); goHome(); });
  searchInput.addEventListener('input', ()=> renderGallery());
  sortSelect.addEventListener('change', ()=> renderGallery());
  filterSelect.addEventListener('change', ()=> renderGallery());
  window.addEventListener('beforeunload', ()=> revokeAllURLs());
}

// ---- helpers used earlier (kept for compat) ----
function readFileAsImage(file){ return new Promise((res,rej)=>{ const fr=new FileReader(); fr.onload=()=>{ const img=new Image(); img.onload=()=>res(img); img.onerror=rej; img.src=fr.result; }; fr.onerror=rej; fr.readAsDataURL(file); }); }
async function processImage(img){ return processImageCore(img); }
async function processImageCore(img, maxWidth=MAX_MAIN_WIDTH, thumbSize=THUMB_SIZE, mime=IMAGE_MIME, quality=IMAGE_QUALITY){
  const ratio = Math.min(1, maxWidth / img.width);
  const w = Math.round(img.width * ratio), h = Math.round(img.height * ratio);
  const c = document.createElement('canvas'); c.width = w; c.height = h;
  const ctx = c.getContext('2d'); ctx.drawImage(img,0,0,w,h);
  const mainBlob = await new Promise(r=>c.toBlob(r, mime, quality));
  const scale = Math.max(thumbSize / img.width, thumbSize / img.height);
  const sw = Math.round(img.width * scale), sh = Math.round(img.height * scale);
  const tmp = document.createElement('canvas'); tmp.width = sw; tmp.height = sh;
  const tctx = tmp.getContext('2d'); tctx.drawImage(img, 0,0, sw, sh);
  const sx = Math.max(0, Math.round((sw - thumbSize) / 2)), sy = Math.max(0, Math.round((sh - thumbSize) / 2));
  const t = document.createElement('canvas'); t.width = thumbSize; t.height = thumbSize;
  t.getContext('2d').drawImage(tmp, sx, sy, thumbSize, thumbSize, 0,0, thumbSize, thumbSize);
  const thumbBlob = await new Promise(r=>t.toBlob(r, mime, quality));
  return { mainBlob, thumbBlob, width: img.width, height: img.height };
}

// === 일괄 다운로드 (ZIP) 기능 추가 시작 ===
(function(){
  try {
    const bulkBtn = document.getElementById('bulkDownloadBtn');
    if (!bulkBtn) return;
    bulkBtn.addEventListener('click', async function(){
      if (!currentPostId) { alert('게시물을 찾을 수 없습니다.'); return; }
      const post = await dbGet(currentPostId);
      if (!post || !post.mainBlobs || post.mainBlobs.length === 0) {
        alert('다운로드할 이미지가 없습니다.');
        return;
      }
      try {
        const zip = new JSZip();
        post.mainBlobs.forEach((blob, idx) => {
          const filename = String(idx+1).padStart(3,'0') + '.jpg';
          zip.file(filename, blob);
        });
        const zipBlob = await zip.generateAsync({type:'blob'});
        const url = URL.createObjectURL(zipBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = ((post.title||'post').replace(/\s+/g,'_')) + '_' + post.id + '.zip';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      } catch(e){
        console.error(e);
        alert('일괄 다운로드 중 오류가 발생했습니다.');
      }
    });
  } catch(e){
    console.error('bulk download setup failed', e);
  }
})();
// === 일괄 다운로드 (ZIP) 기능 추가 끝 ===

</script>
</body>
</html>